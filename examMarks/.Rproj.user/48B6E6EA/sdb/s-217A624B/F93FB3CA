{
    "collab_server" : "",
    "contents" : "#' @title Student Answers for Specific Student\n#'\n#' @description Outputs a students random answers to a multiple choice exam in\n#' the form of a dataframe given the number of questions asked and total number\n#' of questions available. Answers can be from a to e, with NA's indicating the\n#' question was not answered. If writeToFile = TRUE, then studentID and moduleID\n#' must be provided so that the appropriate file name can be created. Files are\n#' created as .tsv's.\n#'\n#' @param totalNumberofQuestions the total number of questions in an exam\n#'\n#' @param numberOfQuestionsToAnswer the amount of questions that the student is\n#' asked\n#'\n#' @param writeToFile if TRUE, a file is created with the dataframe inside. The\n#' default value is set to FALSE.\n#'\n#' @param molduleID a string identifying the name of the module. Only\n#' needed if a file is being written.\n#'\n#' @param studentID a string or value identifying the student that took the exam\n#' Only needed if a file is being written.\n#'\n#' @return a dataframe with a question and answer column with the option to\n#' write dataframe to a file\n#'\n#' @examples\n#' ## create answers for an exam with 100 questions and 30 questions asked\n#' generateStudentAnswersForExam(100, 30)\n#'\n#' ## write the student's randomized answers to a file \"BS281_answers_12.tsv\"\n#' generateStudentAnswersForExam(100, 30, writeToFile = TRUE,\n#'      moduleID = 'BS281', studentID = '12')\n#'\n#' @author Andrew Davis \\email{adavisd@essex.ac.uk}\n\ngenerateStudentAnswersForExam = function(totalNumberofQuestions,\n                                         numberOfQuestionsToAnswer,\n                                         writeToFile = FALSE, moduleID,\n                                         studentID){\n  # make sure numberOfQuestionsToAnswer < totalNumberofQuestions\n  stopifnot(numberOfQuestionsToAnswer < totalNumberofQuestions)\n\n  # grab a random subset of questions from the total number of questions\n  # number grabbed depends on numberOfQuestionsToAnswer\n  question = sort(sample.int(totalNumberofQuestions, numberOfQuestionsToAnswer))\n  # randomly generate the students answers for the questions asked\n  # NA values are included for questiosn that the student skipped\n  answer = sample(c(letters[1:5], NA), numberOfQuestionsToAnswer,\n                  replace = TRUE)\n  # merge question and answer into dataframe for output\n  stuAnswers = data.frame(question, answer)\n\n  # write dataframe to file using moduleID and studentID\n  if(writeToFile == TRUE) {\n    filename = paste0(moduleID, '_answers_', studentID, '.tsv')\n    write.table(stuAnswers, file = filename,\n                row.names = F, quote = F, col.names = T)\n  }\n  # or just ourput dataframe to console\n  return(stuAnswers)\n}\n\n#' @title All Student Answers for a Given Exam\n#'\n#' @description Outputs random answers to a multiple choice exam for a given\n#' module for all students. Answers can be from a to e, with NA's indicating the\n#' question was not answered. If writeToFile = TRUE, then a folder is created\n#' with all of the student answers. A file is also created with the list of\n#' students that took a given exam. Files are created as .tsv's. If\n#' readFromFiles = TRUE, then the arguements numberOfQuestions, allStudentIDs,\n#' and examsPerSubject are read from files instead of from dataframes.\n#'\n#' @param molduleID a string identifying the name of the module.\n#'\n#' @param numberOfQuestions the dataframe that contains the amount of questions\n#' each student needs to answer for each exam. The defualt value, questions, is\n#' a dataframe included in the package.\n#'\n#' @param allStudentIDs the dataframe that contains the ID for each student and\n#' what degree course they are on. The defualt value, students, is a dataframe\n#' included in the package.\n#'\n#' @param examsPerSubject the dataframe that contains a dataframe that lists\n#' what modules a given degree course takes. The first column should list\n#' modules, the second column should list the options for options for\n#' degree 1, and the third column should list options for\n#' degree 2. The possible options are \"Yes\", \"No\", and \"Optional\". If a string\n#' is supplied that is not one of the three then it is evaluated as \"Yes\". if a\n#' module is \"Optional\", then a random amount of students is picked to take the\n#' exam, with a higher number of students being more likely. The defualt value,\n#' exams, is a dataframe included in the package, with degree 1 being\n#' \"Biological Sciences\" and degree 2 being \"Genetics\".\n#'\n#' @param writeToFile if TRUE, a folder, named based on the moduleID is created\n#' with a file for each student's answers. A file is also created that lists all\n#' of the students that took the exam. The default value is set to FALSE.\n#'\n#' @param readFromFiles if TRUE, filenames are used to read in data for the\n#' relevant arguements instead of dataframes within R.\n#'\n#' @param degreeNames if degree names are not \"Biological Sciences\" and\n#' \"Genetics\" then a string should be entered with the two degree courses that\n#' the student set belongs to.\n#'\n#' @return A list with 2 elements, a data frame of students that took the module\n#' and a list of answers by each student. If writeToFile = TRUE, then files are\n#' written instead.\n#'\n#' @examples\n#' ## create answers for BS284 and output to console\n#' generateAllStudentsAnswersForExam('BS284', writeToFile = FALSE)\n#'\n#' ## create files with student answer files and a list of students taking exam\n#' generateAllStudentsAnswersForExam('BS284', writeToFile = TRUE)\n#'\n#' @author Andrew Davis \\email{adavisd@essex.ac.uk}\n\ngenerateAllStudentsAnswersForExam = function(moduleID,\n    numberOfQuestions = questions, allStudentIDs = students,\n    examsPerSubject = exams, writeToFile = FALSE, readFromFiles = FALSE,\n    degreeNames = NULL){\n  # read in files from arguements if arguements are interpreted as filenames\n  if(readFromFiles == TRUE){\n    numberOfQuestions = read.table(file = number_of_questions, header = T)\n    # add total number fo questions asked for each exam to numberOfQuestions\n    totalQuestions = NULL\n    for(i in 1:5){\n      totalQuestions[i] = length(readLines(\n        paste0('correct_answers_BS28', i, '.dat')))\n    }\n    numberOfQuestions = cbind(numberOfQuestions, totalQuestions)\n    allStudentIDs = read.table(file = allStudentIDs, header = T)\n    examsPerSubject = read.table(file = examsPerSubject, header = T)\n  }\n  # otherwise just interpret arguements as objects\n  else{ }\n\n  # edit degree names if degreeNames is not NULL\n  if(!is.null(degreeNames)) degree = degreeNames\n  else degree = c(\"Biological Sciences\", \"Genetics\")\n  colnames(examsPerSubject) =c('module', degree[1], degree[2])\n\n  # add in stop and warning statements to ensure data is ran correctly\n  if(moduleID %in% examsPerSubject[,1] == FALSE){\n    stop('moduleID not listed in examsPerSubject')\n  }\n  stopifnot(names(examsPerSubject) == c(\"module\", degree[1], degree[2]))\n  stopifnot(unique(allStudentIDs[,2]) == degree)\n  if(numberOfQuestions[numberOfQuestions[,1] == moduleID, 2] >\n     numberOfQuestions[numberOfQuestions[,1] == moduleID, 3]){\n    stop('Number of questions asked is more than in module exam answer key')\n  }\n\n  # subset students if only genetic students in module\n  if(examsPerSubject[examsPerSubject[,1] == moduleID, 2] == 'No'){\n    allStudentIDs = allStudentIDs[allStudentIDs[,2] == degree[2],]\n  }\n  # subset students if only biological sciences in module\n  else if(examsPerSubject[examsPerSubject[,1] == moduleID, 3] == 'No'){\n    allStudentIDs = allStudentIDs[allStudentIDs[,2] == degree[1],]\n  }\n  # subset students if optional for genetics\n  # select all biological sciences and a random subset of genetics\n  else if(examsPerSubject[examsPerSubject[,1] == moduleID, 3] == 'Optional'){\n    bioStudents = allStudentIDs[allStudentIDs[,2] == degree[1],]\n    geneticsOpt = allStudentIDs[allStudentIDs[,2] == degree[2],]\n    geneticsOpt = geneticsOpt[sample(1:nrow(geneticsOpt),\n                                     sample(1:nrow(geneticsOpt), 1,\n                                            prob = seq(.2, .8, .6/\n                                                   (nrow(geneticsOpt) - 1)))),]\n    allStudentIDs = rbind(bioStudents, geneticsOpt)\n  }\n  # subset students if optional for biological sciences\n  # select all genetics and a random subset of biological sciences\n  else if(examsPerSubject[examsPerSubject[,1] == moduleID, 2] == 'Optional'){\n    geneticsStudents = allStudentIDs[allStudentIDs[,2] == degree[1],]\n    bioOpt = allStudentIDs[allStudentIDs[,2] == degree[2],]\n    bioOpt = bioOpt[sample(1:nrow(bioOpt), sample(1:nrow(bioOpt), 1,\n                                                  prob = seq(.2, .8, .6/\n                                                  (nrow(bioOpt) - 1)))),]\n    allStudentIDs = rbind(geneticsStudents, bioOpt)\n  }\n  # select random number fo students if module is optional for both degrees\n  else if(examsPerSubject[examsPerSubject[,1] == moduleID, 2] == 'Optional' &\n          examsPerSubject[examsPerSubject[,1] == moduleID, 3] == 'Optional'){\n    allStudentIDs = allStudentIDs[sample(1:nrow(allStudentIDs),\n                                         sample(1:nrow(allStudentIDs), 1,\n                                                prob = seq(.2, .8, .6/\n                                                  (nrow(allStudentIDs) - 1)))),]\n  }\n  # if both degrees take course, then no need to subset students\n  else { }\n\n  # write student answers to files in a folder\n  if(writeToFile == TRUE) {\n    # create directory and change working directory to place files inside\n    dir.create(paste0(moduleID, 'studentAnswerFiles'))\n    setwd(paste0(moduleID, 'studentAnswerFiles'))\n    # use generateStudentAnswersForExam function to create student answers for\n    # all students\n    for(i in allStudentIDs[,1]) {\n      generateStudentAnswersForExam(\n        numberOfQuestions[numberOfQuestions == moduleID, 3],\n        numberOfQuestions[numberOfQuestions == moduleID, 2],\n        TRUE, moduleID, i)\n    }\n    # reset workign directory to original location\n    setwd('../')\n    # create file with list of students to be able to check what students were\n    # randomly selected\n    filename = paste('studentList_', moduleID, '.tsv', sep = '')\n    write.table(allStudentIDs, file = filename, col.names = TRUE,\n                row.names = FALSE)\n  }\n  # otherwise output student answers to console\n  else {\n    # use generateStudentAnswersForExam to create list of answers for each\n    # student with exact number of answers and questions contingent on moduleID\n    allStuAnswers = lapply(allStudentIDs[,1], generateStudentAnswersForExam,\n                           totalNumberofQuestions =\n                            numberOfQuestions[numberOfQuestions ==moduleID, 3],\n                           numberOfQuestionsToAnswer =\n                            numberOfQuestions[numberOfQuestions == moduleID, 2])\n    names(allStuAnswers) = allStudentIDs[,1]\n    # create list with the dataframe of all students taking exam and the list of\n    # student answers\n    allStuAnswers = list(allStudentIDs, allStuAnswers)\n    names(allStuAnswers) = c('student list', 'answers')\n    return(allStuAnswers)\n  }\n}\n\n#' @title Generate Exam Answer Key\n#'\n#' @description Outputs a randomized answer key for a given exam based on\n#' number of questions. If writeToFile = TRUE, then moduleID must be prodived to\n#' create the file name.\n#'\n#' @param numberOfQuestions a numerica value that specifies how many answers\n#' should be generated for the key.\n#'\n#' @param writeToFile if TRUE, a file, named based on the moduleID, is created\n#' with the answer key inside.\n#'\n#' @param moduleID a string that designates what the name of the module is. If\n#' writeToFile = TRUE, then this arguement must be specified.\n#'\n#' @param ansOptions the possible answers in the multiple choice exam key. The\n#' default value, letters[1:5], specifies that there are 5 different options for\n#' each question, a, b, c, d, and e.\n#'\n#' @return a vector that contains a randomized answer for each question number.\n#' If writeToFile = TRUE, then this vector is written to a file.\n#'\n#' @examples\n#' ## create 100 question answer key\n#' createAnswerKey(100)\n#'\n#' ## write answer to key yot file\n#' createAnswerKey(100, writeToFile = TRUE, 'BS281')\n#'\n#' @author Andrew Davis \\email{adavisd@essex.ac.uk}\n\ncreateAnswerKey = function(numberOfQuestions, writeToFile = FALSE, moduleID,\n                           ansOptions = letters[1:5]){\n  answer = sample(ansOptions, numberOfQuestions, replace = TRUE)\n  if(writeToFile == TRUE){\n    write.table(answer, file = paste0('correct_answers_', moduleID, '.dat'),\n                row.names = F, quote = F, col.names = 'answer')\n  }\n  else return(answer)\n}\n",
    "created" : 1493248865322.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2476389494",
    "id" : "F93FB3CA",
    "lastKnownWriteTime" : 1493228184,
    "last_content_update" : 1493228184,
    "path" : "~/R/Learning/BS231/examMarks/R/generateAnswerSheets.R",
    "project_path" : "R/generateAnswerSheets.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}